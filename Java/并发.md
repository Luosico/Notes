# 并发

## 一、线程

### 1、创建方式

#### 继承 **Thread** 类

```java
public class Test extends Thread{

    public static void main(String[] args){
        Thread t = new Test();
        t.start();

    }

    @Override
    public void run() {
        System.out.println("hello");
    }
}
```

#### 实现 **Runnable** 接口

```java
public class Test implements Runnable{

    public static void main(String[] args){
        Thread t = new Thread(new Test());
        t.start();

    }

    @Override
    public void run() {
        System.out.println("Hello");
    }
}
```

#### 线程池

阿里巴巴开发手册推荐使用 **ThreadPoolExecutor** 创建，而不是 **Executors**(其实也是使用ThreadPoolExecutor 创建)

```java
//Executors
public class Test implements Runnable{
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ThreadPoolExecutor pool = (ThreadPoolExecutor) Executors.newCachedThreadPool();
        
        Future future = pool.submit(new Test());
        
        //获取指定线程执行结果
        future.get();

        //使用完，要关闭线程池
        pool.shutdown();
    }

    @Override
    public void run() {
        System.out.println("Hello");
    }
}

//ThreadPoolExecutor
public class Test implements Runnable{
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(10,10,100, TimeUnit.SECONDS,new LinkedBlockingDeque<>());

        pool.execute(new Test());

        //关闭线程池
        pool.shutdown();
    }

    @Override
    public void run() {
        System.out.println("Hello");
    }
}
```

**submit()**其实也是调用了**execute()**方法，知识方法中多了FutureTask接口线程结构并返回

```java
public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
```

### 2、中断线程

#### 请求中断线程

```java
void interrupt();
```

​	发出线程中断请求，并不一定立即发生中断，线程的**中断状态**将被设置为**true**，如果发生**sleep()**，该线程不会休眠，会被阻塞，无法检测中断状态，或者正在sleep()后调用，抛出 `InterruptedException`异常

#### 判断中断状态

```java
static boolean interrupted();
```

#### 获取当前线程

```java
static Thread currentThread();
```

#### 测试当前线程是否被中断

```java
static boolean interrupted();
```

​	副作用：会将当前线程的中断状态重置为false

### 3、线程状态

1. New
2. Runnable
3. Blocked
4. Waiting
5. Timed waiting
6. Terminated

#### 获取当前状态

```java
Thread.State getState();
```

#### 等待线程

```java
// B中 A.join()
//等待A执行完成才继续执行B
void join();

//等待指定线程死亡或等待指定的毫秒数
void join(long millis);
```

### 4、守护线程

```java
void setDeamon(boolean isDeamon);
```

​	唯一用途就是为其他线程提供服务，当只剩下守护线程，虚拟机就退出了

​	守护线程应该永远不去访问固有资源，如文件、数据库，因为他会在任何时候甚至在一个操作的中间发生中断

### 5、未捕获异常处理器

**实现 Thread.UncaughtExceptionHandler接口的类**

线程不能抛出任何**受查异常**，并且**非受查异常**会导致线程终止

不需要任何catch子句来处理可以被传播的异常，在线程死亡之前，异常就被传递到未捕获异常处理器

```java
//设置未捕获异常处理器
public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh);

//为所有线程设置默认处理器
public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)；
```



## 二、ReentrantLock

**可重入锁**

​	确保任何时刻只有一个线程进入临界区，当其他线程调用 lock 时，会被阻塞，知道第一个线程释放锁对象

```java
//默认是非公平锁
ReentrantLock mylock = new ReentrantLock();
//创建公平锁
ReentrantLock mylock = new ReentrantLock(true);
...
//请求锁
mylock.lock();
try{
    //该方法也使用了锁
    fun();
}finally{
    //释放锁，应该在finally中释放锁，否则在临界区抛出异常是，锁不会被释放，其他线程将永远阻塞
    mylock.unlock();
}
```

​	可以重复获得已经持有的锁，锁会保持一个计数，来追踪对lock方法的嵌套调用，**被一个锁保护的代码可以调用另一个使用相同的锁的方法**，当持有计数**变为0**，线程才会**释放锁**

#### 1、条件变量

​	当使用**await()**时，当前线程被阻塞，同时释放锁；直到另一个线程调用**signalAll()**才有机会重新申请锁

```java
ReentrantLock mylock = new ReentrantLock();
Condition con = mylock.newCondition();
...
//释放锁
con.await();
...
//激活所有等待的线程，再次通过竞争获取锁
con.signalAll();

```



## 三、synchronized

也是**可重入锁**，在synchronized修饰的方法内可以调用该对象另一个synchronized修饰的方法

### 1、内部对象锁

​	Java的每个对象都有一个**内部锁**，若synchronized修饰方法，要调用该方法必须先获得内部的对象锁

​	内部对象锁只有一个相关条件，wait()方法添加一个线程到等待集中，notifyAll()/notify()方法解除等待线程的阻塞状态

**只有获得了对象锁才能调用wait()，否则报`IllegalMonitorStateException`异常**

### 2、客户端锁定

**截获对象锁**

```java
public void transfer(Vector accounts){
    //截获accounts对象的对象锁
	synchronized(accounts){
        ...
    }
}
```



## 四、Volatile

 volatile让变量在每次使用时都从主存中取，而不是各个线程的“工作内存”，例如寄存器、本地内存。

具有synchronized的可见性，但没有它的并发正确性，即不能提供原子性

**可以安全的读，不能安全的写**



## 五、多个线程安全的读取一个域

**只能保证安全的读**

### 1、使用锁

### 2、volatile修饰

### 3、声明为final



## 六、原子性

### 1、Atomic

**使用高效的机器级指令来保证原子性**

#### AtomicInteger

- **incrementAndGet / decrementAndGet**

  以原子的方式自增或自减 1 

- **compareAndSet**

  设置任意数值，但这个更新**不是原子**的

  当前是设置的**旧值**时把值设置为想设置的**新值**

  ```java
  AtomicLong m = new AtomicLong();
  
  do{
      oldValue = m.get();
      newValue = 100;
  }while(m.compareAndSet(oldValue,newValue))
   
  ```

  ### 2、LongAdder 和 LongAccumulator

  如果有大量线程访问相同的原子值，性能会大幅下降，因为乐观锁更新需要太多次重试

  可以有多个线程同时更新不同的加数，获取是为它们的总和（工作完后才需要总和的值）



## 七、ThreadLocal

**线程局部变量**

